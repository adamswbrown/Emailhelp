#!/usr/bin/env python3
"""
main_app.py - Native macOS Email Triage Application

A native macOS window application for email triage and categorization.
Uses PyWebView for native window with HTML/CSS/JS UI.

Features:
- Native macOS window (not a browser)
- Direct database access to Mail.app/Outlook
- Compose and send replies
- GPT integration for drafting
- Auto-refresh for new emails
- Mark emails as done
"""

import webview
import json
import sys
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Optional

# Import our existing modules
from email_reader import create_reader
from scoring import EmailScorer
from classifier import EmailClassifier
from preview import EmailPreview
from reply_handler import ReplyHandler
from actions.gpt_export import GPTExporter
from actions.mark_done import DoneTracker


class EmailTriageAPI:
    """Backend API for the email triage application."""
    
    def __init__(self, client='auto', account='ews'):
        """
        Initialize the API.
        
        Args:
            client: Email client ('auto', 'apple-mail', or 'outlook')
            account: Default account to filter
        """
        self.client = client
        self.account = account
        self.reader = None
        self.scorer = EmailScorer()
        self.classifier = EmailClassifier()
        self._done_tracker = DoneTracker()
        self.reply_handler = None
        
        # Initialize reader
        try:
            self.reader = create_reader(client=client if client != 'auto' else None)
            
            # Determine which client we're using for reply handler
            detected_client = 'apple-mail'
            if hasattr(self.reader, '__class__'):
                class_name = self.reader.__class__.__name__
                if 'Outlook' in class_name:
                    detected_client = 'outlook'
            
            self.reply_handler = ReplyHandler(client=detected_client)
            
        except Exception as e:
            print(f"Error initializing reader: {e}", file=sys.stderr)
            raise
    
    def get_emails(self, account: str = None, limit: int = 50, since_days: int = 7, category_filter: str = None):
        """
        Get categorized emails.
        
        Args:
            account: Account to filter (default: self.account)
            limit: Maximum number of emails
            since_days: Days to look back
            category_filter: Filter by category (ACTION, FYI, IGNORE)
        
        Returns:
            JSON string of email list
        """
        try:
            if account is None:
                account = self.account
            
            with self.reader:
                messages = self.reader.query_messages(
                    account=account,
                    limit=limit,
                    since_days=since_days
                )
            
            # Process and categorize
            emails = []
            print(f"[API] Processing {len(messages)} messages...", file=sys.stderr)
            for msg in messages:
                # Get email ID
                email_id = msg.get('message_id') or msg.get('ROWID')
                
                # Skip if marked as done
                if self._done_tracker.is_done(email_id):
                    continue
                
                # Extract fields
                sender = msg.get('sender', '') or ''
                subject = msg.get('subject', '') or ''
                # Extract preview - try multiple sources
                # Extract preview - try multiple sources
                preview = msg.get('preview', '') or msg.get('Message_Preview', '')
                
                # If no preview in database, try extracting from .emlx file
                if not preview:
                    emlx_path = msg.get('emlx_path') or msg.get('message_path')
                    if emlx_path:
                        try:
                            from pathlib import Path
                            if Path(emlx_path).exists():
                                preview = EmailPreview.extract_from_emlx(emlx_path)
                                # Clean up preview
                                if preview:
                                    import re
                                    # Remove HTML and clean whitespace
                                    preview = re.sub(r'<[^>]+>', '', preview)
                                    preview = ' '.join(preview.split())
                        except Exception as e:
                            print(f"[API] Preview extraction from .emlx failed: {e}", file=sys.stderr)
                            preview = ''
                
                # Clean up any preview we got
                if preview:
                    import re
                    # Remove HTML tags if any
                    preview = re.sub(r'<[^>]+>', '', preview)
                    # Remove excessive whitespace
                    preview = ' '.join(preview.split())
                    # Limit length for display (but keep full for scoring)
                    preview_display = preview[:300] + '...' if len(preview) > 300 else preview
                else:
                    preview_display = 'No preview available'
                
                score, signals = self.scorer.score_email(sender, subject, preview)
                
                # Classify
                category = self.classifier.classify(score).value
                
                # Filter by category if requested
                if category_filter and category != category_filter:
                    continue
                
                # Format date
                date_received = msg.get('date_received', 0)
                if date_received:
                    date_obj = datetime.fromtimestamp(date_received)
                    date_str = date_obj.strftime('%d/%m/%Y %H:%M')
                    time_ago = self._format_time_ago(date_received)
                else:
                    date_str = 'Unknown'
                    time_ago = ''
                
                emails.append({
                    'id': email_id,
                    'from': sender,
                    'subject': subject,
                    'date': date_received,
                    'date_str': date_str,
                    'time_ago': time_ago,
                    'score': score,
                    'category': category,
                    'signals': signals,
                    'preview': preview_display if 'preview_display' in locals() else (preview[:200] if preview else 'No preview available'),
                    'mailbox': msg.get('mailbox', ''),
                    'read': msg.get('read', 1) == 1
                })
            
            # Sort by date (newest first)
            emails.sort(key=lambda x: x['date'], reverse=True)
            
            return json.dumps(emails)
            
        except Exception as e:
            print(f"Error getting emails: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc()
            return json.dumps([])
    
    def _format_time_ago(self, timestamp: int) -> str:
        """Format timestamp as 'X hours ago' etc."""
        now = datetime.now().timestamp()
        diff = now - timestamp
        
        if diff < 3600:
            mins = int(diff / 60)
            return f"{mins} min{'s' if mins != 1 else ''} ago"
        elif diff < 86400:
            hours = int(diff / 3600)
            return f"{hours} hour{'s' if hours != 1 else ''} ago"
        else:
            days = int(diff / 86400)
            return f"{days} day{'s' if days != 1 else ''} ago"
    
    def send_reply(self, email_id: str, reply_body: str, reply_all: bool = False):
        """
        Send a reply to an email.
        
        Args:
            email_id: Email ID
            reply_body: Reply text
            reply_all: Whether to reply all
        
        Returns:
            JSON result
        """
        try:
            # Get email details
            email = self._get_email_by_id(email_id)
            if not email:
                return json.dumps({
                    "success": False,
                    "message": "Email not found"
                })
            
            # Send reply
            result = self.reply_handler.send_reply(email, reply_body, reply_all)
            
            # Mark as done if successful
            if result['success']:
                self._done_tracker.mark_done(email_id)
            
            return json.dumps(result)
            
        except Exception as e:
            return json.dumps({
                "success": False,
                "message": f"Error sending reply: {str(e)}"
            })
    
    def open_reply_window(self, email_id: str, reply_body: str = ""):
        """
        Open reply window in Mail.app/Outlook.
        
        Args:
            email_id: Email ID
            reply_body: Pre-filled body text
        
        Returns:
            JSON result
        """
        try:
            email = self._get_email_by_id(email_id)
            if not email:
                return json.dumps({
                    "success": False,
                    "message": "Email not found"
                })
            
            result = self.reply_handler.open_reply_window(email, reply_body)
            return json.dumps(result)
            
        except Exception as e:
            return json.dumps({
                "success": False,
                "message": f"Error opening reply window: {str(e)}"
            })
    
    def _get_email_by_id(self, email_id: str) -> Optional[Dict]:
        """Get email details by ID."""
        try:
            with self.reader:
                messages = self.reader.query_messages(limit=1000)
            
            for msg in messages:
                msg_id = str(msg.get('message_id') or msg.get('ROWID'))
                if msg_id == str(email_id):
                    return {
                        'sender': msg.get('sender', ''),
                        'subject': msg.get('subject', ''),
                        'date': msg.get('date_received', 0),
                        'content': msg.get('preview', ''),
                        'cc': msg.get('cc', '')
                    }
            
            return None
            
        except Exception as e:
            print(f"Error getting email by ID: {e}", file=sys.stderr)
            return None
    
    def export_to_gpt(self, email_id: str, for_draft: bool = False):
        """
        Export email to clipboard for GPT.
        
        Args:
            email_id: Email ID
            for_draft: Whether to format for draft reply request
        
        Returns:
            JSON result
        """
        try:
            # Get full email details
            emails_json = self.get_emails(limit=1000)
            emails = json.loads(emails_json)
            
            email = next((e for e in emails if str(e['id']) == str(email_id)), None)
            if not email:
                return json.dumps({
                    "success": False,
                    "message": "Email not found"
                })
            
            # Format for GPT
            if for_draft:
                context = GPTExporter.export_for_draft_reply(email)
            else:
                context = GPTExporter.export_for_analysis(email)
            
            # Copy to clipboard
            if GPTExporter.copy_to_clipboard(context):
                return json.dumps({
                    "success": True,
                    "message": "Copied to clipboard! Paste into ChatGPT."
                })
            else:
                return json.dumps({
                    "success": False,
                    "message": "Failed to copy to clipboard"
                })
            
        except Exception as e:
            return json.dumps({
                "success": False,
                "message": f"Error exporting to GPT: {str(e)}"
            })
    
    def mark_done(self, email_id: str):
        """Mark email as done."""
        try:
            self._done_tracker.mark_done(email_id)
            return json.dumps({"success": True})
        except Exception as e:
            return json.dumps({
                "success": False,
                "message": str(e)
            })
    
    def mark_undone(self, email_id: str):
        """Unmark email as done."""
        try:
            self._done_tracker.mark_undone(email_id)
            return json.dumps({"success": True})
        except Exception as e:
            return json.dumps({
                "success": False,
                "message": str(e)
            })
    
    def get_templates(self):
        """Get quick reply templates."""
        templates = self.reply_handler.get_templates()
        return json.dumps(templates)
    
    def get_template_body(self, template_id: str):
        """Get body for a specific template."""
        body = self.reply_handler.get_template_body(template_id)
        return json.dumps({"body": body if body else ""})


    
    def run_evaluation(self, days: int = 60, limit: int = 500):
        """
        Run categorization evaluation on recent emails.
        
        Args:
            days: Number of days to analyze
            limit: Maximum emails to analyze
            
        Returns:
            JSON with evaluation results and suggestions
        """
        from analyze_emails import analyze_emails
        
        try:
            print(f"[API] Running evaluation: days={days}, limit={limit}", file=sys.stderr)
            
            # Run analysis
            results = analyze_emails(
                limit=limit,
                since_days=days,
                client=self.client if self.client != 'auto' else None,
                account=self.account
            )
            
            if not results:
                return json.dumps({
                    "success": False,
                    "message": "No emails found to analyze"
                })
            
            # Extract key metrics
            total = results.get('total_emails', 0)
            categories = results.get('category_distribution', {})
            recommendations = results.get('recommendations', {})
            
            return json.dumps({
                "success": True,
                "total_emails": total,
                "categories": {k: v for k, v in categories.items()},
                "score_stats": {
                    "average": recommendations.get('patterns_found', {}).get('average_score', 0),
                    "range": list(recommendations.get('patterns_found', {}).get('score_range', [0, 0]))
                },
                "suggestions": {
                    "trusted_domains": recommendations.get('trusted_domains', [])[:5],
                    "threshold_adjustments": recommendations.get('threshold_adjustments', {}),
                    "action_phrases": dict(list(results.get('action_phrases_in_content', {}).items())[:10]),
                    "info_phrases": dict(list(results.get('informational_phrases_in_content', {}).items())[:10])
                },
                "patterns": recommendations.get('patterns_found', {})
            })
            
        except Exception as e:
            print(f"[API] Evaluation error: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc(file=sys.stderr)
            return json.dumps({
                "success": False,
                "message": f"Evaluation failed: {str(e)}"
            })
    
    def get_current_thresholds(self):
        """Get current categorization thresholds."""
        return json.dumps({
            "action_threshold": self.classifier.ACTION_THRESHOLD,
            "fyi_threshold": self.classifier.FYI_THRESHOLD
        })
    
    def apply_threshold_adjustment(self, new_action_threshold: int):
        """
        Apply new ACTION threshold (in-memory only).
        
        Args:
            new_action_threshold: New threshold value (20-90)
            
        Returns:
            JSON with result
        """
        try:
            new_action_threshold = int(new_action_threshold)
            
            # Validate
            if new_action_threshold < 20 or new_action_threshold > 90:
                return json.dumps({
                    "success": False,
                    "message": "Threshold must be between 20 and 90"
                })
            
            old_threshold = self.classifier.ACTION_THRESHOLD
            
            # Update in-memory
            self.classifier.ACTION_THRESHOLD = new_action_threshold
            self.classifier.FYI_THRESHOLD = max(10, new_action_threshold - 10)
            
            print(f"[API] Threshold updated: {old_threshold} -> {new_action_threshold}", file=sys.stderr)
            
            return json.dumps({
                "success": True,
                "old_threshold": old_threshold,
                "new_threshold": new_action_threshold,
                "message": f"Threshold updated! Refresh emails to see changes.",
                "note": "This change is temporary until you restart the app."
            })
            
        except Exception as e:
            return json.dumps({
                "success": False,
                "message": str(e)
            })

def main():
    """Start the native macOS application."""
    import argparse
    
    parser = argparse.ArgumentParser(description='Email Triage Native App')
    parser.add_argument('--client', choices=['auto', 'apple-mail', 'outlook'], default='auto',
                        help='Email client to use')
    parser.add_argument('--account', default='ews',
                        help='Default account to filter')
    
    args = parser.parse_args()
    
    # Initialize API
    try:
        api = EmailTriageAPI(client=args.client, account=args.account)
    except Exception as e:
        print(f"Failed to initialize: {e}", file=sys.stderr)
        sys.exit(1)
    
    # Get UI path
    ui_path = Path(__file__).parent / 'ui' / 'dashboard.html'
    
    if not ui_path.exists():
        print(f"Error: UI file not found at {ui_path}", file=sys.stderr)
        sys.exit(1)
    
    # Create window
    window = webview.create_window(
        'Email Triage',
        str(ui_path),
        js_api=api,
        width=1400,
        height=900,
        resizable=True,
        frameless=False,
        easy_drag=True
    )
    
    # Start app
    webview.start(debug=True)


if __name__ == '__main__':
    main()
